{"ast":null,"code":"import _classCallCheck from \"/Users/chalanthornaenguthaivadt/Desktop/Thesis/Gold-Inventory-Management-System/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/chalanthornaenguthaivadt/Desktop/Thesis/Gold-Inventory-Management-System/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/chalanthornaenguthaivadt/Desktop/Thesis/Gold-Inventory-Management-System/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/chalanthornaenguthaivadt/Desktop/Thesis/Gold-Inventory-Management-System/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport * as utils from './utils.js';\nimport { Base } from './Base.js';\nexport var Pointer = /*#__PURE__*/function (_Base) {\n  _inherits(Pointer, _Base);\n  var _super = _createSuper(Pointer);\n  function Pointer(offsetType, type) {\n    var _this;\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    _classCallCheck(this, Pointer);\n    _this = _super.call(this);\n    _this.offsetType = offsetType;\n    _this.type = type;\n    _this.options = options;\n    if (_this.type === 'void') {\n      _this.type = null;\n    }\n    if (_this.options.type == null) {\n      _this.options.type = 'local';\n    }\n    if (_this.options.allowNull == null) {\n      _this.options.allowNull = true;\n    }\n    if (_this.options.nullValue == null) {\n      _this.options.nullValue = 0;\n    }\n    if (_this.options.lazy == null) {\n      _this.options.lazy = false;\n    }\n    if (_this.options.relativeTo) {\n      if (typeof _this.options.relativeTo !== 'function') {\n        throw new Error('relativeTo option must be a function');\n      }\n      _this.relativeToGetter = options.relativeTo;\n    }\n    return _this;\n  }\n  _createClass(Pointer, [{\n    key: \"decode\",\n    value: function decode(stream, ctx) {\n      var _this2 = this;\n      var offset = this.offsetType.decode(stream, ctx);\n\n      // handle NULL pointers\n      if (offset === this.options.nullValue && this.options.allowNull) {\n        return null;\n      }\n      var relative;\n      switch (this.options.type) {\n        case 'local':\n          relative = ctx._startOffset;\n          break;\n        case 'immediate':\n          relative = stream.pos - this.offsetType.size();\n          break;\n        case 'parent':\n          relative = ctx.parent._startOffset;\n          break;\n        default:\n          var c = ctx;\n          while (c.parent) {\n            c = c.parent;\n          }\n          relative = c._startOffset || 0;\n      }\n      if (this.options.relativeTo) {\n        relative += this.relativeToGetter(ctx);\n      }\n      var ptr = offset + relative;\n      if (this.type != null) {\n        var val = null;\n        var decodeValue = function decodeValue() {\n          if (val != null) {\n            return val;\n          }\n          var pos = stream.pos;\n          stream.pos = ptr;\n          val = _this2.type.decode(stream, ctx);\n          stream.pos = pos;\n          return val;\n        };\n\n        // If this is a lazy pointer, define a getter to decode only when needed.\n        // This obviously only works when the pointer is contained by a Struct.\n        if (this.options.lazy) {\n          return new utils.PropertyDescriptor({\n            get: decodeValue\n          });\n        }\n        return decodeValue();\n      } else {\n        return ptr;\n      }\n    }\n  }, {\n    key: \"size\",\n    value: function size(val, ctx) {\n      var parent = ctx;\n      switch (this.options.type) {\n        case 'local':\n        case 'immediate':\n          break;\n        case 'parent':\n          ctx = ctx.parent;\n          break;\n        default:\n          // global\n          while (ctx.parent) {\n            ctx = ctx.parent;\n          }\n      }\n      var type = this.type;\n      if (type == null) {\n        if (!(val instanceof VoidPointer)) {\n          throw new Error(\"Must be a VoidPointer\");\n        }\n        var _val = val;\n        type = _val.type;\n        val = val.value;\n      }\n      if (val && ctx) {\n        // Must be written as two separate lines rather than += in case `type.size` mutates ctx.pointerSize.\n        var size = type.size(val, parent);\n        ctx.pointerSize += size;\n      }\n      return this.offsetType.size();\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(stream, val, ctx) {\n      var relative;\n      var parent = ctx;\n      if (val == null) {\n        this.offsetType.encode(stream, this.options.nullValue);\n        return;\n      }\n      switch (this.options.type) {\n        case 'local':\n          relative = ctx.startOffset;\n          break;\n        case 'immediate':\n          relative = stream.pos + this.offsetType.size(val, parent);\n          break;\n        case 'parent':\n          ctx = ctx.parent;\n          relative = ctx.startOffset;\n          break;\n        default:\n          // global\n          relative = 0;\n          while (ctx.parent) {\n            ctx = ctx.parent;\n          }\n      }\n      if (this.options.relativeTo) {\n        relative += this.relativeToGetter(parent.val);\n      }\n      this.offsetType.encode(stream, ctx.pointerOffset - relative);\n      var type = this.type;\n      if (type == null) {\n        if (!(val instanceof VoidPointer)) {\n          throw new Error(\"Must be a VoidPointer\");\n        }\n        var _val2 = val;\n        type = _val2.type;\n        val = val.value;\n      }\n      ctx.pointers.push({\n        type: type,\n        val: val,\n        parent: parent\n      });\n      return ctx.pointerOffset += type.size(val, parent);\n    }\n  }]);\n  return Pointer;\n}(Base);\n\n// A pointer whose type is determined at decode time\nexport var VoidPointer = /*#__PURE__*/_createClass(function VoidPointer(type, value) {\n  _classCallCheck(this, VoidPointer);\n  this.type = type;\n  this.value = value;\n});","map":{"version":3,"names":["utils","Base","Pointer","offsetType","type","options","allowNull","nullValue","lazy","relativeTo","Error","relativeToGetter","stream","ctx","offset","decode","relative","_startOffset","pos","size","parent","c","ptr","val","decodeValue","PropertyDescriptor","get","VoidPointer","value","pointerSize","encode","startOffset","pointerOffset","pointers","push"],"sources":["/Users/chalanthornaenguthaivadt/Desktop/Thesis/Gold-Inventory-Management-System/node_modules/restructure/src/Pointer.js"],"sourcesContent":["import * as utils from './utils.js';\nimport {Base} from './Base.js';\n\nexport class Pointer extends Base {\n  constructor(offsetType, type, options = {}) {\n    super();\n    this.offsetType = offsetType;\n    this.type = type;\n    this.options = options;\n    if (this.type === 'void') { this.type = null; }\n    if (this.options.type == null) { this.options.type = 'local'; }\n    if (this.options.allowNull == null) { this.options.allowNull = true; }\n    if (this.options.nullValue == null) { this.options.nullValue = 0; }\n    if (this.options.lazy == null) { this.options.lazy = false; }\n    if (this.options.relativeTo) {\n      if (typeof this.options.relativeTo !== 'function') {\n        throw new Error('relativeTo option must be a function');\n      }\n      this.relativeToGetter = options.relativeTo;\n    }\n  }\n\n  decode(stream, ctx) {\n    const offset = this.offsetType.decode(stream, ctx);\n\n    // handle NULL pointers\n    if ((offset === this.options.nullValue) && this.options.allowNull) {\n      return null;\n    }\n\n    let relative;\n    switch (this.options.type) {\n      case 'local':     relative = ctx._startOffset; break;\n      case 'immediate': relative = stream.pos - this.offsetType.size(); break;\n      case 'parent':    relative = ctx.parent._startOffset; break;\n      default:\n        var c = ctx;\n        while (c.parent) {\n          c = c.parent;\n        }\n\n        relative = c._startOffset || 0;\n    }\n\n    if (this.options.relativeTo) {\n      relative += this.relativeToGetter(ctx);\n    }\n\n    const ptr = offset + relative;\n\n    if (this.type != null) {\n      let val = null;\n      const decodeValue = () => {\n        if (val != null) { return val; }\n\n        const { pos } = stream;\n        stream.pos = ptr;\n        val = this.type.decode(stream, ctx);\n        stream.pos = pos;\n        return val;\n      };\n\n      // If this is a lazy pointer, define a getter to decode only when needed.\n      // This obviously only works when the pointer is contained by a Struct.\n      if (this.options.lazy) {\n        return new utils.PropertyDescriptor({\n          get: decodeValue});\n      }\n\n      return decodeValue();\n    } else {\n      return ptr;\n    }\n  }\n\n  size(val, ctx) {\n    const parent = ctx;\n    switch (this.options.type) {\n      case 'local': case 'immediate':\n        break;\n      case 'parent':\n        ctx = ctx.parent;\n        break;\n      default: // global\n        while (ctx.parent) {\n          ctx = ctx.parent;\n        }\n    }\n\n    let { type } = this;\n    if (type == null) {\n      if (!(val instanceof VoidPointer)) {\n        throw new Error(\"Must be a VoidPointer\");\n      }\n\n      ({ type } = val);\n      val = val.value;\n    }\n\n    if (val && ctx) {\n      // Must be written as two separate lines rather than += in case `type.size` mutates ctx.pointerSize.\n      let size = type.size(val, parent);\n      ctx.pointerSize += size;\n    }\n\n    return this.offsetType.size();\n  }\n\n  encode(stream, val, ctx) {\n    let relative;\n    const parent = ctx;\n    if ((val == null)) {\n      this.offsetType.encode(stream, this.options.nullValue);\n      return;\n    }\n\n    switch (this.options.type) {\n      case 'local':\n        relative = ctx.startOffset;\n        break;\n      case 'immediate':\n        relative = stream.pos + this.offsetType.size(val, parent);\n        break;\n      case 'parent':\n        ctx = ctx.parent;\n        relative = ctx.startOffset;\n        break;\n      default: // global\n        relative = 0;\n        while (ctx.parent) {\n          ctx = ctx.parent;\n        }\n    }\n\n    if (this.options.relativeTo) {\n      relative += this.relativeToGetter(parent.val);\n    }\n\n    this.offsetType.encode(stream, ctx.pointerOffset - relative);\n\n    let { type } = this;\n    if (type == null) {\n      if (!(val instanceof VoidPointer)) {\n        throw new Error(\"Must be a VoidPointer\");\n      }\n\n      ({ type } = val);\n      val = val.value;\n    }\n\n    ctx.pointers.push({\n      type,\n      val,\n      parent\n    });\n\n    return ctx.pointerOffset += type.size(val, parent);\n  }\n}\n\n// A pointer whose type is determined at decode time\nexport class VoidPointer {\n  constructor(type, value) {\n    this.type = type;\n    this.value = value;\n  }\n}\n"],"mappings":";;;;AAAA,OAAO,KAAKA,KAAK,MAAM,YAAY;AACnC,SAAQC,IAAI,QAAO,WAAW;AAE9B,WAAaC,OAAO;EAAA;EAAA;EAClB,iBAAYC,UAAU,EAAEC,IAAI,EAAgB;IAAA;IAAA,IAAdC,OAAO,uEAAG,CAAC,CAAC;IAAA;IACxC;IACA,MAAKF,UAAU,GAAGA,UAAU;IAC5B,MAAKC,IAAI,GAAGA,IAAI;IAChB,MAAKC,OAAO,GAAGA,OAAO;IACtB,IAAI,MAAKD,IAAI,KAAK,MAAM,EAAE;MAAE,MAAKA,IAAI,GAAG,IAAI;IAAE;IAC9C,IAAI,MAAKC,OAAO,CAACD,IAAI,IAAI,IAAI,EAAE;MAAE,MAAKC,OAAO,CAACD,IAAI,GAAG,OAAO;IAAE;IAC9D,IAAI,MAAKC,OAAO,CAACC,SAAS,IAAI,IAAI,EAAE;MAAE,MAAKD,OAAO,CAACC,SAAS,GAAG,IAAI;IAAE;IACrE,IAAI,MAAKD,OAAO,CAACE,SAAS,IAAI,IAAI,EAAE;MAAE,MAAKF,OAAO,CAACE,SAAS,GAAG,CAAC;IAAE;IAClE,IAAI,MAAKF,OAAO,CAACG,IAAI,IAAI,IAAI,EAAE;MAAE,MAAKH,OAAO,CAACG,IAAI,GAAG,KAAK;IAAE;IAC5D,IAAI,MAAKH,OAAO,CAACI,UAAU,EAAE;MAC3B,IAAI,OAAO,MAAKJ,OAAO,CAACI,UAAU,KAAK,UAAU,EAAE;QACjD,MAAM,IAAIC,KAAK,CAAC,sCAAsC,CAAC;MACzD;MACA,MAAKC,gBAAgB,GAAGN,OAAO,CAACI,UAAU;IAC5C;IAAC;EACH;EAAC;IAAA;IAAA,OAED,gBAAOG,MAAM,EAAEC,GAAG,EAAE;MAAA;MAClB,IAAMC,MAAM,GAAG,IAAI,CAACX,UAAU,CAACY,MAAM,CAACH,MAAM,EAAEC,GAAG,CAAC;;MAElD;MACA,IAAKC,MAAM,KAAK,IAAI,CAACT,OAAO,CAACE,SAAS,IAAK,IAAI,CAACF,OAAO,CAACC,SAAS,EAAE;QACjE,OAAO,IAAI;MACb;MAEA,IAAIU,QAAQ;MACZ,QAAQ,IAAI,CAACX,OAAO,CAACD,IAAI;QACvB,KAAK,OAAO;UAAMY,QAAQ,GAAGH,GAAG,CAACI,YAAY;UAAE;QAC/C,KAAK,WAAW;UAAED,QAAQ,GAAGJ,MAAM,CAACM,GAAG,GAAG,IAAI,CAACf,UAAU,CAACgB,IAAI,EAAE;UAAE;QAClE,KAAK,QAAQ;UAAKH,QAAQ,GAAGH,GAAG,CAACO,MAAM,CAACH,YAAY;UAAE;QACtD;UACE,IAAII,CAAC,GAAGR,GAAG;UACX,OAAOQ,CAAC,CAACD,MAAM,EAAE;YACfC,CAAC,GAAGA,CAAC,CAACD,MAAM;UACd;UAEAJ,QAAQ,GAAGK,CAAC,CAACJ,YAAY,IAAI,CAAC;MAAC;MAGnC,IAAI,IAAI,CAACZ,OAAO,CAACI,UAAU,EAAE;QAC3BO,QAAQ,IAAI,IAAI,CAACL,gBAAgB,CAACE,GAAG,CAAC;MACxC;MAEA,IAAMS,GAAG,GAAGR,MAAM,GAAGE,QAAQ;MAE7B,IAAI,IAAI,CAACZ,IAAI,IAAI,IAAI,EAAE;QACrB,IAAImB,GAAG,GAAG,IAAI;QACd,IAAMC,WAAW,GAAG,SAAdA,WAAW,GAAS;UACxB,IAAID,GAAG,IAAI,IAAI,EAAE;YAAE,OAAOA,GAAG;UAAE;UAE/B,IAAQL,GAAG,GAAKN,MAAM,CAAdM,GAAG;UACXN,MAAM,CAACM,GAAG,GAAGI,GAAG;UAChBC,GAAG,GAAG,MAAI,CAACnB,IAAI,CAACW,MAAM,CAACH,MAAM,EAAEC,GAAG,CAAC;UACnCD,MAAM,CAACM,GAAG,GAAGA,GAAG;UAChB,OAAOK,GAAG;QACZ,CAAC;;QAED;QACA;QACA,IAAI,IAAI,CAAClB,OAAO,CAACG,IAAI,EAAE;UACrB,OAAO,IAAIR,KAAK,CAACyB,kBAAkB,CAAC;YAClCC,GAAG,EAAEF;UAAW,CAAC,CAAC;QACtB;QAEA,OAAOA,WAAW,EAAE;MACtB,CAAC,MAAM;QACL,OAAOF,GAAG;MACZ;IACF;EAAC;IAAA;IAAA,OAED,cAAKC,GAAG,EAAEV,GAAG,EAAE;MACb,IAAMO,MAAM,GAAGP,GAAG;MAClB,QAAQ,IAAI,CAACR,OAAO,CAACD,IAAI;QACvB,KAAK,OAAO;QAAE,KAAK,WAAW;UAC5B;QACF,KAAK,QAAQ;UACXS,GAAG,GAAGA,GAAG,CAACO,MAAM;UAChB;QACF;UAAS;UACP,OAAOP,GAAG,CAACO,MAAM,EAAE;YACjBP,GAAG,GAAGA,GAAG,CAACO,MAAM;UAClB;MAAC;MAGL,IAAMhB,IAAI,GAAK,IAAI,CAAbA,IAAI;MACV,IAAIA,IAAI,IAAI,IAAI,EAAE;QAChB,IAAI,EAAEmB,GAAG,YAAYI,WAAW,CAAC,EAAE;UACjC,MAAM,IAAIjB,KAAK,CAAC,uBAAuB,CAAC;QAC1C;QAAC,WAEWa,GAAG;QAAZnB,IAAI,QAAJA,IAAI;QACPmB,GAAG,GAAGA,GAAG,CAACK,KAAK;MACjB;MAEA,IAAIL,GAAG,IAAIV,GAAG,EAAE;QACd;QACA,IAAIM,IAAI,GAAGf,IAAI,CAACe,IAAI,CAACI,GAAG,EAAEH,MAAM,CAAC;QACjCP,GAAG,CAACgB,WAAW,IAAIV,IAAI;MACzB;MAEA,OAAO,IAAI,CAAChB,UAAU,CAACgB,IAAI,EAAE;IAC/B;EAAC;IAAA;IAAA,OAED,gBAAOP,MAAM,EAAEW,GAAG,EAAEV,GAAG,EAAE;MACvB,IAAIG,QAAQ;MACZ,IAAMI,MAAM,GAAGP,GAAG;MAClB,IAAKU,GAAG,IAAI,IAAI,EAAG;QACjB,IAAI,CAACpB,UAAU,CAAC2B,MAAM,CAAClB,MAAM,EAAE,IAAI,CAACP,OAAO,CAACE,SAAS,CAAC;QACtD;MACF;MAEA,QAAQ,IAAI,CAACF,OAAO,CAACD,IAAI;QACvB,KAAK,OAAO;UACVY,QAAQ,GAAGH,GAAG,CAACkB,WAAW;UAC1B;QACF,KAAK,WAAW;UACdf,QAAQ,GAAGJ,MAAM,CAACM,GAAG,GAAG,IAAI,CAACf,UAAU,CAACgB,IAAI,CAACI,GAAG,EAAEH,MAAM,CAAC;UACzD;QACF,KAAK,QAAQ;UACXP,GAAG,GAAGA,GAAG,CAACO,MAAM;UAChBJ,QAAQ,GAAGH,GAAG,CAACkB,WAAW;UAC1B;QACF;UAAS;UACPf,QAAQ,GAAG,CAAC;UACZ,OAAOH,GAAG,CAACO,MAAM,EAAE;YACjBP,GAAG,GAAGA,GAAG,CAACO,MAAM;UAClB;MAAC;MAGL,IAAI,IAAI,CAACf,OAAO,CAACI,UAAU,EAAE;QAC3BO,QAAQ,IAAI,IAAI,CAACL,gBAAgB,CAACS,MAAM,CAACG,GAAG,CAAC;MAC/C;MAEA,IAAI,CAACpB,UAAU,CAAC2B,MAAM,CAAClB,MAAM,EAAEC,GAAG,CAACmB,aAAa,GAAGhB,QAAQ,CAAC;MAE5D,IAAMZ,IAAI,GAAK,IAAI,CAAbA,IAAI;MACV,IAAIA,IAAI,IAAI,IAAI,EAAE;QAChB,IAAI,EAAEmB,GAAG,YAAYI,WAAW,CAAC,EAAE;UACjC,MAAM,IAAIjB,KAAK,CAAC,uBAAuB,CAAC;QAC1C;QAAC,YAEWa,GAAG;QAAZnB,IAAI,SAAJA,IAAI;QACPmB,GAAG,GAAGA,GAAG,CAACK,KAAK;MACjB;MAEAf,GAAG,CAACoB,QAAQ,CAACC,IAAI,CAAC;QAChB9B,IAAI,EAAJA,IAAI;QACJmB,GAAG,EAAHA,GAAG;QACHH,MAAM,EAANA;MACF,CAAC,CAAC;MAEF,OAAOP,GAAG,CAACmB,aAAa,IAAI5B,IAAI,CAACe,IAAI,CAACI,GAAG,EAAEH,MAAM,CAAC;IACpD;EAAC;EAAA;AAAA,EA1J0BnB,IAAI;;AA6JjC;AACA,WAAa0B,WAAW,6BACtB,qBAAYvB,IAAI,EAAEwB,KAAK,EAAE;EAAA;EACvB,IAAI,CAACxB,IAAI,GAAGA,IAAI;EAChB,IAAI,CAACwB,KAAK,GAAGA,KAAK;AACpB,CAAC"},"metadata":{},"sourceType":"module"}