{"ast":null,"code":"import _classCallCheck from \"/Users/chalanthornaenguthaivadt/Desktop/final_thesis/gims/gims-frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/chalanthornaenguthaivadt/Desktop/final_thesis/gims/gims-frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/chalanthornaenguthaivadt/Desktop/final_thesis/gims/gims-frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/chalanthornaenguthaivadt/Desktop/final_thesis/gims/gims-frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Struct } from './Struct.js';\nvar getPath = function getPath(object, pathArray) {\n  return pathArray.reduce(function (prevObj, key) {\n    return prevObj && prevObj[key];\n  }, object);\n};\nexport var VersionedStruct = /*#__PURE__*/function (_Struct) {\n  _inherits(VersionedStruct, _Struct);\n  var _super = _createSuper(VersionedStruct);\n  function VersionedStruct(type) {\n    var _this;\n    var versions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, VersionedStruct);\n    _this = _super.call(this);\n    _this.type = type;\n    _this.versions = versions;\n    if (typeof type === 'string') {\n      _this.versionPath = type.split('.');\n    }\n    return _this;\n  }\n  _createClass(VersionedStruct, [{\n    key: \"decode\",\n    value: function decode(stream, parent) {\n      var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var res = this._setup(stream, parent, length);\n      if (typeof this.type === 'string') {\n        res.version = getPath(parent, this.versionPath);\n      } else {\n        res.version = this.type.decode(stream);\n      }\n      if (this.versions.header) {\n        this._parseFields(stream, res, this.versions.header);\n      }\n      var fields = this.versions[res.version];\n      if (fields == null) {\n        throw new Error(\"Unknown version \".concat(res.version));\n      }\n      if (fields instanceof VersionedStruct) {\n        return fields.decode(stream, parent);\n      }\n      this._parseFields(stream, res, fields);\n      if (this.process != null) {\n        this.process.call(res, stream);\n      }\n      return res;\n    }\n  }, {\n    key: \"size\",\n    value: function size(val, parent) {\n      var includePointers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var key, type;\n      if (!val) {\n        throw new Error('Not a fixed size');\n      }\n      if (this.preEncode != null) {\n        this.preEncode.call(val);\n      }\n      var ctx = {\n        parent: parent,\n        val: val,\n        pointerSize: 0\n      };\n      var size = 0;\n      if (typeof this.type !== 'string') {\n        size += this.type.size(val.version, ctx);\n      }\n      if (this.versions.header) {\n        for (key in this.versions.header) {\n          type = this.versions.header[key];\n          if (type.size != null) {\n            size += type.size(val[key], ctx);\n          }\n        }\n      }\n      var fields = this.versions[val.version];\n      if (fields == null) {\n        throw new Error(\"Unknown version \".concat(val.version));\n      }\n      for (key in fields) {\n        type = fields[key];\n        if (type.size != null) {\n          size += type.size(val[key], ctx);\n        }\n      }\n      if (includePointers) {\n        size += ctx.pointerSize;\n      }\n      return size;\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(stream, val, parent) {\n      var key, type;\n      if (this.preEncode != null) {\n        this.preEncode.call(val, stream);\n      }\n      var ctx = {\n        pointers: [],\n        startOffset: stream.pos,\n        parent: parent,\n        val: val,\n        pointerSize: 0\n      };\n      ctx.pointerOffset = stream.pos + this.size(val, ctx, false);\n      if (typeof this.type !== 'string') {\n        this.type.encode(stream, val.version);\n      }\n      if (this.versions.header) {\n        for (key in this.versions.header) {\n          type = this.versions.header[key];\n          if (type.encode != null) {\n            type.encode(stream, val[key], ctx);\n          }\n        }\n      }\n      var fields = this.versions[val.version];\n      for (key in fields) {\n        type = fields[key];\n        if (type.encode != null) {\n          type.encode(stream, val[key], ctx);\n        }\n      }\n      var i = 0;\n      while (i < ctx.pointers.length) {\n        var ptr = ctx.pointers[i++];\n        ptr.type.encode(stream, ptr.val, ptr.parent);\n      }\n    }\n  }]);\n  return VersionedStruct;\n}(Struct);","map":{"version":3,"names":["Struct","getPath","object","pathArray","reduce","prevObj","key","VersionedStruct","type","versions","versionPath","split","stream","parent","length","res","_setup","version","decode","header","_parseFields","fields","Error","process","call","val","includePointers","preEncode","ctx","pointerSize","size","pointers","startOffset","pos","pointerOffset","encode","i","ptr"],"sources":["/Users/chalanthornaenguthaivadt/Desktop/final_thesis/gims/gims-frontend/node_modules/restructure/src/VersionedStruct.js"],"sourcesContent":["import {Struct} from './Struct.js';\n\nconst getPath = (object, pathArray) => {\n  return pathArray.reduce((prevObj, key) => prevObj && prevObj[key], object);\n};\n\nexport class VersionedStruct extends Struct {\n  constructor(type, versions = {}) {\n    super();\n    this.type = type;\n    this.versions = versions;\n    if (typeof type === 'string') {\n      this.versionPath = type.split('.');\n    }\n  }\n\n  decode(stream, parent, length = 0) {\n    const res = this._setup(stream, parent, length);\n\n    if (typeof this.type === 'string') {\n      res.version = getPath(parent, this.versionPath);\n    } else {\n      res.version = this.type.decode(stream);\n    }\n\n    if (this.versions.header) {\n      this._parseFields(stream, res, this.versions.header);\n    }\n\n    const fields = this.versions[res.version];\n    if ((fields == null)) {\n      throw new Error(`Unknown version ${res.version}`);\n    }\n\n    if (fields instanceof VersionedStruct) {\n      return fields.decode(stream, parent);\n    }\n\n    this._parseFields(stream, res, fields);\n\n    if (this.process != null) {\n      this.process.call(res, stream);\n    }\n    return res;\n  }\n\n  size(val, parent, includePointers = true) {\n    let key, type;\n    if (!val) {\n      throw new Error('Not a fixed size');\n    }\n\n    if (this.preEncode != null) {\n      this.preEncode.call(val);\n    }\n\n    const ctx = {\n      parent,\n      val,\n      pointerSize: 0\n    };\n\n    let size = 0;\n    if (typeof this.type !== 'string') {\n      size += this.type.size(val.version, ctx);\n    }\n\n    if (this.versions.header) {\n      for (key in this.versions.header) {\n        type = this.versions.header[key];\n        if (type.size != null) {\n          size += type.size(val[key], ctx);\n        }\n      }\n    }\n\n    const fields = this.versions[val.version];\n    if ((fields == null)) {\n      throw new Error(`Unknown version ${val.version}`);\n    }\n\n    for (key in fields) {\n      type = fields[key];\n      if (type.size != null) {\n        size += type.size(val[key], ctx);\n      }\n    }\n\n    if (includePointers) {\n      size += ctx.pointerSize;\n    }\n\n    return size;\n  }\n\n  encode(stream, val, parent) {\n    let key, type;\n    if (this.preEncode != null) {\n      this.preEncode.call(val, stream);\n    }\n\n    const ctx = {\n      pointers: [],\n      startOffset: stream.pos,\n      parent,\n      val,\n      pointerSize: 0\n    };\n\n    ctx.pointerOffset = stream.pos + this.size(val, ctx, false);\n\n    if (typeof this.type !== 'string') {\n      this.type.encode(stream, val.version);\n    }\n\n    if (this.versions.header) {\n      for (key in this.versions.header) {\n        type = this.versions.header[key];\n        if (type.encode != null) {\n          type.encode(stream, val[key], ctx);\n        }\n      }\n    }\n\n    const fields = this.versions[val.version];\n    for (key in fields) {\n      type = fields[key];\n      if (type.encode != null) {\n        type.encode(stream, val[key], ctx);\n      }\n    }\n\n    let i = 0;\n    while (i < ctx.pointers.length) {\n      const ptr = ctx.pointers[i++];\n      ptr.type.encode(stream, ptr.val, ptr.parent);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}